/*
    Title:   Roman Font GDL description
    Authors: Martin Hosken, Bob Hallissy, Joan Wardell, Sharon Correll
    
    Changes:
SJC 2008-Oct     More changes for ditto
SJC 2008-Aug-26  Various changes for small-caps, deprecated PUA, etc.
SJC 2008-Apr-23  Changed Tat alternates back to H-stroke alternates
SJC 2008-Apr-15  Patch (kludge) to handle dotless i w/ alternate tail
AKW 2008-Apr-02  Restore hookabove glyphs to Vietnamese diacritic classes
SJC 2007-Oct-31  Added #ifs for Gentium Basic and Gentium Book Basic
SJC 2007-Jan-26  Cleaned up distinction between Open-O alternates and J-stroke-hook-alternate
SJC 2006-Dec-4   Various changes for new version to support Unicode 5.0:
	Changed VNStyle to vN; added Chinantec tones, Cyrillic cursive italics, open-o serif feature
SJC 2006 ??????  Added barred-j modifier to take smaller diacritics; added smallcaps code (turned off)
SJC 2006-Apr-6   Allow ogonek and literacy rules to both fire
SJC 2006-Mar-21  Handle literacy alternates + Vietnamese diacritics for NFC data
SJC 2006-Jan-23  Added Cyrillic shha alternate
SJC 2005-Oct-14  Added slant-italic ff, fi, fl ligatures
SJC 2005-Oct-13  Made ff, fi, fl true ligatures with components.
SJC 2005-Oct-12  Fixed problems with dotted modifier super/subscripts and partial fix for F17A (double diaeresis).
SJC 2005-Sep-1   Added slant-italic special forms, diaersis on superscripts, and bridging diacritics.
SJC 2005-May-16  Handle features modlowcolon, ltnglottalstop, and ltnjstroke.
SJC 2005-May-16  Turn off AutoPseudo.
SJC 2005-May-10  Added a few comments.
AKW 2005-May-09  Changed gF176 to g035C (PUA character accepted into Unicode).
JMW 2004-Sep-02  For now, I will take easy option on fixing Literacy Alts and Romanian,
    by backing up. Later I may re-write. Input to WP2 is now NFD, necessitating a change.
JMW 2004-Jul-21  Comments on Viet, add 4th Eng.
RMH 2004-Mar-17  Changed logic for ou alternates due to default is now closed top,
	and alternate is .OpenType  (issue RFS-5WXH4D);
	added omacron and Omacron to things that can composite with ogonek (related to issue RFS-5X5FKC);
	renamed cnDia to cDia -- it is a class of all diacritics, not the class of non-diacritics;
	added cHDia to cBDia, but I think the cBDia and cnBDia classes aren't used...?
RMH 2004-Feb-25  removed all smartcode that builds alternates (of composites) by decomposition
	(we now have real alternates available in the font);
	in the process, eliminated viet.gdh -- integrating it directly here.
RMH 2004-Feb-13  Made explicit associations to quiet new GrCompiler warnings.
RMH 2004-Feb-05  Rewrote rules that had been generated by normal_rules() function in makegdl.pl so
	that (1) only those glyphs that need composition (things with ogonek, cedilla, horn)
	are actually composed, and (2) now permits other diacritcs to intervene.
	Similarly added code to permit intevening diacs in rules for .vNStyle diac ligatures.
RMH 2004-Feb-04 Changes after B14: implemented logic for retrohookstyle ogonek alternates feature.
RMH 2004-Jan-19 Changes after B10: omehow p_hook feature wasn't ever implemented.
RMH 10-Oct-2003 Significant rework:
	added "else" clauses for most features (so this same code works if
	Feature table and cmap are changed so an "alternate" glyph is the default);
	added code to handle cedillas that need to be rendered as commaaccent;
	added DeBuG feature (only compiled in if symbol DEBUG is defined as non-zero).
RMH 01-Sep-2003 Reworked all features per PC's design.
RMH 15-Aug-2003  Added other Unicode 4.0 double-diacritics;
    fixed double diacritic positioning so not dependent on glyph's default location
	(requires double diacritics should NOT have attachment points).
RMH 17-Jul-2003  Removed all references to "P" and "_P" attachment points -- it no longer exists;
    replace refs to U+F177 with U+035E (Unicode 4.0).
RMH 10-Jul-2003  Added logic to decompose 1E2D and 1ECB in the context of upper diacritics.
MJPH 16-Nov-2002 Move overarch to down by -1200m from -700m.
*/

#include "stddef.gdh"

#define CHARISfont 1
#define DOULOSfont 2
#define GENTIUMBASICfont 3
#define GENTIUMBOOKBASICfont 4
#define GENTIUMfont 5
#define GENTIUMBOOKfont 6
#define ANDIKABASICfont 7
#define ANDIKAfont 8

/////#define GENBASICfamily (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont)
#define BASIC (FONT == GENTIUMBASICfont || FONT == GENTIUMBOOKBASICfont || FONT == ANDIKABASICfont)
#define ANDIKAfamily (FONT == ANDIKAfont || FONT == ANDIKABASICfont)

// Now turn on the font we want, so we get specific features. (This file is copied from
// something like doulos.gdh or charis.gdh by the build process.
#include "fontSpecific.gdh"

#define DEBUG 0
// #define DEBUG 1  //jw 7/21/04 Use this to turn on DEBUG

#define SMALLCAPS 0

Bidi = 0;

// We handle double-encoded glyphs by hand, for the deprecated-PUA feature.
AutoPseudo = 0;

#define DIASTR3(x) [ x [ x x?]?]?
#define DIASTR4(x) [ x [ x [ x x?]?]?]?
#define DIASTR5(x) [ x [ x [ x [ x x?]?]?]?]?
#define attached user1

// user1 - user4 are used in pitches.gdh
// (user1 is used by pitch and attachment stuff because there should not be any conflict)

#define pua user5


#if DEBUG
#define DeBuG g__d g_e g__b g_u g__g g_colon 
#endif

//////////////////////////////////////////////////////////////////////////////////////
//
//	Glyphs
//

table(glyph);

// To make upstream whitespace be reordered at the end of a line; shouldn't be
// needed if compiler is working correctly.
//clsSpaces = (g_space, g2000, g2001, g2002, g2003, g2004, g2005
//				g2006, g2007, g2008, g2009, g200A, g200B)
//			{ dir = DIR_WHITESPACE };


// Additions to feature classes for small caps; these are not included
// automatically by make_gdl.

cBaselineHook += (g_eng_baseline_hook_s_c); // but these classes aren't really used
cUCStyle += (g_eng_u_c_style_s_c);
cKom += (g_eng_kom_s_c);
cno_BaselineHook += (g_eng_s_c);
cno_UCStle += (g_eng_s_c);
cno_Kom += (g_eng_s_c);

cTopBar += (g0253_topBar_sC);
cno_TopBar += (g0253_sC);

cVertStrk += (g_hbar_vert_strk_s_c);
cno_VertStrk += (g_hbar_s_c);

cCommaStyle += (g_scedilla_comma_style_s_c, g0163_commaStyle_sC);
cno_CommaStyle += (g_scedilla_s_c, g0163_sC);

cTopSerif += (g0254_topSerif_sC);
cno_TopSerif += (g0254_sC);

cLCStyleNhook = (g019d_lCStyle, g0272_lCStyle_sC);
cno_LCStyleNhook = (g019d, g0272_sC);

cLCStyleRtail = (g2c64_lCStyle, g027d_lCStyle_sC); // what about lowercase r-tail SC?
cno_LCStyleRtail = (g2c64, g027d_sC);

cRtHookThook = (g01ac_rtHook, g01ad_rtHook_sC);
cno_RtHookThook = (g01ac, g01ad_sC);

cRtHookYhook = (g01b3_rtHook, g01b4_rtHook_sC);
cno_RtHookYhook = (g01b3, g01b4_sC);

cStraightLft += (g028b_straightLft_sC);
cStraightLftHighHook += (g028b_straightLftHighHook_sC);
cno_StraightLft += (g028b_sC);
cno_StraightLftHighHook += (g028b_sC);

cRevSigmaStyle += (g04e1_revSigmaStyle_sC, g0292_revSigmaStyle_sC);
cno_RevSigmaStyle += (g04e1_sC, g0292_sC);

cOpenTop += (g0223_openTop_sC);
cno_OpenTop += (g0223_sC);

cMongolStyle += (g044d_mongolStyle_sC);
cno_MongolStyle += (g044d_sC);

cLrg += (ga78c_lrg_sC);
cno_Lrg += (ga78c_sC);

// Why is there no g_lcaron_caron_sC??



// Classes of double-diacritics above and below:
#if BASIC
cUDblDia = (g035e);
cLDblDia = (g035f);
#else
cUDblDia = (g035d  g035e  g0360  g0361  gf17a	g1dcd);
cLDblDia = (g035f  g0362  g035c);
#endif // !BASIC

// Various classes of diacritics; the classes generated by make_gdl are not helpful.
cBDia = (cLDia cODia cHDia);				// Below = Lower + Ogonek + Cedilla
cnBDiaX = (cUDia cRDia);					// Not Below
cnHDiaX = (cLDia cODia cRDia cUDia);		// Not Cedilla
cnLDiaX = (cHDia cODia cRDia cUDia);		// Not Lower
cnODiaX = (cHDia cLDia cRDia cUDia);		// Not Ogonek
cnRDiaX = (cHDia cLDia cODia cUDia);		// Not Horn (right)
cnUDiaX = (cHDia cLDia cODia cRDia );		// Not Upper
cDia =  (cHDia cLDia cODia cRDia cUDia);	// Any (but not double dias)

// ff, fi, fl ligatures
#if !BASIC

cfLigC2 = (g_f  g_i  g_l);
cfLig  = (g_f_f  g_f_i  g_f_l);
cffLigC3 = (g_i  g_l);
cffLig = (g_f_f_i  g_f_f_l);

cfLigC2_slantItalic  = (g_f_slant_italic, g_i_slant_italic, g_l_slant_italic);
cfLig_slantItalic    = (g_f_f_slant_italic, g_f_i_slant_italic, g_f_l_slant_italic);
cffLigC3_slantItalic = (g_i_slant_italic, g_l_slant_italic);
cffLig_slantItalic   = (g_f_f_i_slant_italic, g_f_f_l_slant_italic);

cfLig_all = (cfLig  cfLig_slantItalic)
	{ component {f1 = box(0, -descent, aw/2, ascent); f2 = box(aw/2, -descent, aw, ascent) }};
cffLig_all = (cffLig  cffLig_slantItalic)
	{ component { f1 = box(0, -descent, aw/3, ascent);
					f2 = box(aw/3, -descent, (2*aw)/3, ascent);
					f3 = box((2*aw)/3, -descent, aw, ascent) }}
#endif // !BASIC

#if BASIC
cSpecialDotted = (g1ecb);
cSpecialDottedDia = (g_dotbelowcomb);
#else
cSpecialDotted = (g1e2d  g1ecb);
cSpecialDottedDia = (g0330  g_dotbelowcomb);
#endif // !BASIC

// Special class defs for cedilla compositions that are rendered as commaaccent:
#if !BASIC
cCedillaBase = (g__g  g_g  g__k  g_k  g__l  g_l  g__n  g_n  g__r  g_r);
cCedillaComposite = (g__gcommaaccent g_gcommaaccent g__kcommaaccent g_kcommaaccent
		g__lcommaaccent	g_lcommaaccent g__ncommaaccent g_ncommaaccent g__rcommaaccent
		g_rcommaaccent);
#endif // !BASIC

// Add in other cedilla composites:
#if BASIC
cCedillaBase += (g__c  g_c  g__e  g_e)
cCedillaComposite += (g__ccedilla  g_ccedilla  g0228  g0229)
#else
cCedillaBase += (g__c  g_c  g__s  g_s  g__t  g_t  g__e  g_e  g_s_s_c  g_t_s_c)
cCedillaComposite += (g__ccedilla g_ccedilla g__scedilla g_scedilla
		g0162  g0163  g0228  g0229  g_scedilla_s_c  g0163_sC)
#endif // !BASIC

// Ogonek composites:
#if !BASIC
cOgonekBase = (g__a  g_a  g__e  g_e  g__u  g_u  g__o  g_o  g__omacron  g_omacron);
cOgonekComposite = (g__aogonek g_aogonek g__eogonek g_eogonek g__uogonek
		g_uogonek  g01ea  g01eb  g01ec  g01ed);
#endif // !BASIC

// Horn composites:
cHornBase = (g__o  g_o  g__u  g_u);
cHornComposite = (g__ohorn  g_ohorn  g__uhorn  g_uhorn);

// Modifier superscripts that require smaller diacritics:
#if BASIC
cModSuper = (g02c0);
#else
cModSuper = (g02b0  g02b1  g02b2  g02b3  g02b4  g02b5  g02b6  g02b7  g02b8
		g02c0  g02c1  g02e0  g02e1  g02e2  g02e3  g02e4
		g1d2c  g1d2d  g1d2e  g1d2f
		g1d30  g1d31  g1d32  g1d33  g1d34  g1d35  g1d36  g1d37
		g1d38  g1d39  g1d3a  g1d3b  g1d3c  g1d3d  g1d3e  g1d3f
		g1d40  g1d41  g1d42  g1d43  g1d44  g1d45  g1d46  g1d47
		g1d48  g1d49  g1d4a  g1d4b  g1d4c  g1d4d  g1d4e  g1d4f
		g1d50  g1d51  g1d52  g1d53  g1d54  g1d55  g1d56  g1d57
		g1d58  g1d59  g1d5a  g1d5b  g1d5c  g1d5d  g1d5e  g1d5f  g1d60  g1d61  g1d78
		g1d9b  g1d9c  g1d9d  g1d9e  g1d9f
		g1da0  g1da1  g1da2  g1da3  g1da4  g1da5  g1da6  g1da7
		g1da8  g1da9  g1daa  g1dab  g1dac  g1dad  g1dae  g1daf
		g1db0  g1db1  g1db2  g1db3  g1db4  g1db5  g1db6  g1db7
		g1db8  g1db9  g1dba  g1dbb  g1dbc  g1dbd  g1dbe  g1dbf  g2071  g207f
		g2071_dotless  g02b2_dotless  g1da4_dotless  g1da8_dotless);
		
// Modifier subscripts that require smaller diacritics:
cModSub = (g1d62  g1d63  g1d64  g1d65  g1d66  g1d67  g1d68  g1d69  g1d6a
		g2090  g2091  g2092  g2093  g2094
		g1d62_dotless);
#endif // !BASIC

// Vietnamese diacritic combinations
cDiacComb = (g_acutecomb g_gravecomb g_hookabovecomb g_tildecomb);
c_g0302DiacComb = ( g0302_acutecomb_vN		g0302_gravecomb_vN
					g0302_hookabovecomb_vN	g0302_tildecomb_vN);
c_g0306DiacComb = (	g0306_acutecomb_vN		g0306_gravecomb_vN
					g0306_hookabovecomb_vN	g0306_tildecomb_vN);
						

// Vietnamese/literacy combinations

// a with stacked diacritics
c_aStack_noLit = (g1ea5  g1ea7  g1ea9  g1eab  g1eaf  g1eb1  g1eb5  g1eb3); // eg, a+circum+acute
c_diacComb_vN = (g0302_acutecomb_vN, g0302_gravecomb_vN,
			g0302_hookabovecomb_vN, g0302_tildecomb_vN, 
			g0306_acutecomb_vN, g0306_gravecomb_vN,
			g0306_hookabovecomb_vN, g0306_tildecomb_vN);


#if !BASIC
// These caron combinations are treated specially by European languages, which is the default:
cCaronEuro = (g_dcaron, g_lcaron, g__lcaron, g_lcaron_s_c, g_tcaron);
cno_CaronEuro = (g_d, g_l, g__l, g_l_s_c, g_t);

// These work for Doulos:
g_dcaron {comp {base = box(0, bb.bottom-50m, (3*aw)/4, bb.top+50m);
                caron = box((3*aw)/4, bb.top - 450m, aw,bb.top+50m) }};
                 
g_lcaron {comp {base = box(0,bb.bottom-70m, (2*aw)/3, bb.top+50m);
                caron = box((5*aw)/8, bb.top - 450m, aw,bb.top+50m) }};
                 
g__lcaron {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-200m,bb.top+50m) }};
                 
g_lcaron_s_c {comp {base = box(0,bb.bottom-50m, aw/2+70m, bb.top+50m);
                caron = box(bb.right-450m, bb.top-500m, bb.right-100m,bb.top+50m) }};

g_tcaron {comp {base = box(0,bb.bottom-50m, bb.right-200m, bb.top-200m);
                caron = box(bb.right-300m, bb.top-450m, bb.right+50m, bb.top+50m) }};
#endif // !BASIC


// Uppercase-eng variations
// (The extra composite glyphs aren't really needed, they only happen to be in the font for AAT.)
c_eng_Descender = (g__eng, g_eng_s_c);                    // cno_BaselineHook = cno_Kom
c_eng_UCStyle = (g__eng_u_c_style, g_eng_u_c_style_s_c);  // (g__eng_u_c_style, g014A0301_uCStyle, g014A0300_uCStyle, g014A0302_uCStyle, g014A0303_uCStyle, g014A0323_uCStyle);
c_eng_BaselineHook = (g__eng_baseline_hook, g_eng_baseline_hook_s_c);  // cBaselineHook;
c_eng_Kom = (g__eng_kom, g_eng_kom_s_c);                  // cKom;

// V-hook variations
c_vhook_Curved = cno_StraightLft; // = cno_StraightLftHighHook
c_vhook_StraightLeft = cStraightLft;
c_vhook_HighHook = cStraightLftHighHook;

// Cyrillic shha (uses same tag as uppercase eng so we define these clases by hand):
cUCStyleCyrShha = (g04bb_uCStyle, g04bb_uCStyle_sC);
cno_UCStyleCyrShha = (g04bb, g04bb_sC);

// We need to add these explicitly because makegdl does not recognize the fact that
// 'g_dotlessi_slant_italic' need to be in the cDotless class.
// TODO: recheck when we switch over to the new version of make_gdl.
cDotless += g_dotlessi_slant_italic; // g_dotlessi_tail_i;
cno_Dotless += g_i_slant_italic;     // g_i_tail_i;

cno_BrInvBreve = (g0311    g0361);
cBrInvBreve_uU = (g0311_uU g0361_uU);
cBrInvBreve_uL = (g0311_uL g0361_uL);
cBrInvBreve_lL = (g0311_lL g0361_lL);

#if !BASIC
cBridgeDiac = ( g0308_uU  g0308_uL  g0308_lL
				g0311_uU  g0311_uL  g0311_lL
				g0361_uU  g0361_uL  g0361_lL);
#endif // !BASIC

endtable; // glyph

#include "pua.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Features
//

#include "features.gdh"


//////////////////////////////////////////////////////////////////////////////////////
//
//	Rules
//

table(substitution);

pass(1)  {MaxBackup = 15; MaxRuleLoop = 30}

c_pua  >  c_noPua {pua = 1}  /  ^ _ ;

if (smallcaps)
	cno_SC  > cSC;
endif;

// For the special briding diacritic stuff, upper diacritics need to come first so they will attach
// to the first base (0311 and 0361 seem to be treated differently by NFD).
if (bridging_diac)
	cLDblDia  cUDblDia   >   @2  @1;
endif;

endpass;


pass(2)  {MaxBackup = 15; MaxRuleLoop = 30}

// Turn combining half-marks into one double-width combining mark
#if !BASIC
gfe20=d1  gfe21=d2  >  g0361:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;
gfe22=d1  gfe23=d2  >  g0360:(d1 d2) _  /  ^ _  cTakesUDia  DIASTR5(cDia)  _ ;

// For Chinantec, make the standard Unicode characters look like the special PUA characters.
if (chinantec_tone == 1)
	cno_ChinantecTn  >  cChinantecTn;
else
	cChinantecTn  >  cno_ChinantecTn;
endif;

// Handle ogoneks; backup needed to also handle literacy feature:
cOgonekBase  g0328  >  cOgonekComposite:(b d)  _  / ^ _=b  DIASTR4(cnODiaX)  _=d;
#endif // !BASIC

// Handle cedillas (including those that need to look like comma-accent by precomposing them);
// back-up needed to also handle rom feature:
cCedillaBase  g0327  > cCedillaComposite:(b d)  _  / ^ _=b  DIASTR4(cnHDiaX)  _=d;
// Handle horns:
cHornBase  g031b  >  cHornComposite:(b d)  _  /  _=b  DIASTR4(cnRDiaX)  _=d;

// Handle Vietnamese
/* jw comments
     2 stacked diacs go to side-by-side unless there is an intervening upper diac.
     pre-composed base + stacked diacs go to pre-composed base+side-by-side (cVN) */
if (viet == 1)
	// decompose the stacked form and replace the base 'a' with the literacy form,
	// the diacritics with the Vietnamese form
	_  c_aStack_noLit  >  g_a_sng_story:2  c_diacComb_vN / _ _ {literacy == 1};
	
	g0302 cDiacComb  >  c_g0302DiacComb$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	g0306 cDiacComb  >  c_g0306DiacComb$d:(b d)  _  / _=b DIASTR4(cnUDiaX) _=d;
	cno_VN > cVN; // ie, when literacy == false
else
	cVN > cno_VN;
endif;

#if !BASIC
if (bridging_diac)
  // LL with bridging diaeresis (U+035F is possible intervening bridging underbar)
  g0308  >  g0308_uU  /  g__l  g035f?  _  g035f?  g__l;
  g0308  >  g0308_uL  /  g__l  g035f?  _  g035f?  g_l;
  g0308  >  g0308_lL  /  g_l   g035f?  _  g035f?  g_l;
  
  // OU with bridging inverted breve (0311 / 0361)
  cno_BrInvBreve  >  cBrInvBreve_uU  /  g__o  g035f?  _  g035f?  g__u;
  cno_BrInvBreve  >  cBrInvBreve_uL  /  g__o  g035f?  _  g035f?  g_u;
  cno_BrInvBreve  >  cBrInvBreve_lL  /  g_o   g035f?  _  g035f?  g_u;
endif;
#endif // !BASIC

#if DEBUG

if (debug == 1)
	g_question > g_one		/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 0};
	g_question > g_two		/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 1};
	g_question > g_three	/ DeBuG g_space g_e g_n g_g g_equal _ {eng == 2};
endif;

#endif  // DEBUG

/*
# NOTES:
#
# The rules are designed so that they work correctly no matter how the 
# default value for a feature is set. While this means the rules don't
# demand that the cmap and feature table agree on the default glyph, 
# the font will be more usable in non-GDL apps if they do agree.
# (One exception remaining is vietnamese processing -- so don't
# try to build a font with vietnamese on by default).
#
# If a glyph name extension (which is what drives the class names) is used 
# within more than one feature (e.g., .LrgBowl is used in the Rams horn alternate 
# and the Small ezh-curl alternate), then we cannot use the automatically generated
# class names (e.g., cLrgBowl and cno_LrgBowl), but rather must explicitly
# handle each glyph -- sigh.
*/

if (eng == descender)
	// for fonts with default = base, capital, or short:
	c_eng_BaselineHook  >  c_eng_Descender;
	c_eng_UCStyle       >  c_eng_Descender;
	c_eng_Kom           >  c_eng_Descender;
endif;
if (eng == base)
	// for fonts with default = descender, capital, or short:
	c_eng_Descender   >  c_eng_BaselineHook;
	c_eng_UCStyle     >  c_eng_BaselineHook;
	c_eng_Kom         >  c_eng_BaselineHook;
endif;
if (eng == capital)
	// for fonts with default = descender, base, or short:
	c_eng_Descender    >  c_eng_UCStyle;
	c_eng_BaselineHook >  c_eng_UCStyle;
	c_eng_Kom          >  c_eng_UCStyle;
endif;
if (eng == short)
	// for fonts with default = descender, capital, or base:
	c_eng_Descender    >  c_eng_Kom;
	c_eng_BaselineHook >  c_eng_Kom;
	c_eng_UCStyle      >  c_eng_Kom;
endif;

#if !BASIC
if (ramshorn == small)
	// for fonts with default = large or gamma
	(g0264_lrgBowl  g0264_gammaStyle) > g0264;
endif;
if (ramshorn == large)
	// for fonts with default = small or gamma
	(g0264 	g0264_gammaStyle)	> g0264_lrgBowl;
endif;
if (ramshorn == gamma)
	// for fonts with default = small or large
	(g0264  g0264_lrgBowl)		> g0264_gammaStyle;
endif

// supernum feature dealt with in pitches.gdh

if (mongol_e == 1)
	cno_MongolStyle > cMongolStyle;
else
	cMongolStyle >cno_MongolStyle;
endif;
#endif // !BASIC

#if 1 // FONT != DOULOSfont
/**** obsolete feature
if (cyr_curs_ital == 1)
	cno_Cursive  >  cCursive;
else
	cCursive  >  cno_Cursive;
endif;
****/
#endif // !DOULOSfont

#if !BASIC

if (short_breve == 1)
	cno_CyShortMrkAlt > cCyShortMrkAlt;
else
	cCyShortMrkAlt > cno_CyShortMrkAlt;
endif;

if (invis == 1)
	cno_ShowInv > cShowInv;
endif;

#endif // !BASIC


// NB: Because 01E5 is affected by two features, barred_bowl and literacy,
// these features take special organization of their rules. Specifically,
// 01E5 should be displayed as:
//	if Literacy Alternates then LtnSmGBarredSngBowl (uni01E5.BarBowl.SngBowl)
//	else if Barred-Bowl Forms then LtnSmGBarredBowl (uni01E5.BarBowl)
//	else LtnSmGStrk (uni01E5)
// Note also that uni01E5 doesn't show up in any class


// Note: literacy alternates take precedence over slant-italic feature (below).
if (literacy == 1)
	cno_SngBowl  > cSngBowl;		// (includes uni01E5.BarBowl > uni01E5.BarBowl.SngBowl)
	cno_SngStory > cSngStory;
#if !BASIC ////////////////////// FIX THIS!!!!!!!!!!!!!!
	g01e5  >  g01e5_barBowl_sngBowl;
#endif // !BASIC
else
	cSngBowl  > cno_SngBowl;		// (includes uni01E5.BarBowl.SngBowl > uni01E5.BarBowl)
	cSngStory > cno_SngStory;	
endif;

// TODO: the code below will have to be extended somewhat to correctly handle the case where
// the slant-italic glyphs are the default.
#if !BASIC
if (slant_italic == 1)
  // ff, fi, fl ligatures
  g_f cfLigC2 > g_f_slant_italic cfLigC2_slantItalic   / _ _ cDia;  // don't create a ligature, a following diac stops ligature from forming
  g_f cfLigC2 > _ cfLig_slantItalic:(1 2) {component {f1.ref = @1; f2.ref = @2}};

  g_f g_f cffLigC3 > g_f_slant_italic g_f_slant_italic cffLigC3_slantItalic  / _ _ _ cDia;  // don't create a ligature
  g_f g_f cffLigC3 > _ _ cffLig_slantItalic:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

  cno_SlantItalic  >  cSlantItalic;		// f, i, l, v
  cno_2StorySlantItalic  >  c2StorySlantItalic;  // a, ae
else
  // ff, fi, fl ligatures
  g_f cfLigC2 > @1 @2 / _ _ cDia; // do nothing, a following diac stops ligature from forming
  g_f cfLigC2 > _ cfLig:(1 2) {component {f1.ref = @1; f2.ref = @2}};

  g_f g_f cffLigC3 > @1 @2 @3 / _ _ _ cDia;  // do nothing
  g_f g_f cffLigC3 > _ _ cffLig:(1 2 3) {component {f1.ref = @1; f2.ref = @2; f3.ref = @3}};

  cSlantItalic  >  cno_SlantItalic;
  c2StorySlantItalic  >  cno_2StorySlantItalic;
endif;

// The barred_bowl rule must happen *after* the literacy rule
if (barred_bowl == 1)                   //  does contain g01E5, no such naming as uni01e5 or
                                        // uni anything. That is the Postscript Name from xml file.  jw 8/27/04
	cno_BarBowl  >  cBarBowl;	// (does NOT include uni01E5 > uni01E5.BarBowl)
//	g01e5  >  g01e5_barBowl;		        yes it does jw.  commented 8/31 
//					see: cno_BarBowl = (g0180, g_dcroat, g01e5);
else
	cBarBowl  >  cno_BarBowl;	// (does NOT include uni01E5.BarBowl > uni01E5)
//	g01e5_barBowl  >  g01e5;			yes it does jw
endif;

if (ltnjstroke == doubleSerif)
	cno_DblSerif  >  cDblSerif;
else
	cDblSerif  >  cno_DblSerif;
endif;
#endif // !BASIC

if (open_o == topSerif)
	cno_TopSerif  >  cTopSerif;
else
	cTopSerif  >  cno_TopSerif;
endif;

#if !(BASIC)
if (v_hook == curved)
	c_vhook_StraightLeft >  c_vhook_Curved;
	c_vhook_HighHook     >  c_vhook_Curved;
endif;
if (v_hook == straightLeft)
	c_vhook_Curved    >  c_vhook_StraightLeft;
	c_vhook_HighHook  >  c_vhook_StraightLeft;
endif;
if (v_hook == highHook)
	c_vhook_Curved       >  c_vhook_HighHook;
	c_vhook_StraightLeft >  c_vhook_HighHook;
endif;
#endif // !BASIC

if (y_hook == 1)
	cno_RtHookYhook  >  cRtHookYhook;
else
	cRtHookYhook  >  cno_RtHookYhook;
endif;

if (n_hook == 1)
	cno_LCStyleNhook  >  cLCStyleNhook;
else
	cLCStyleNhook  >  cno_LCStyleNhook;
endif;

#if !BASIC
if (ezh_curl == 1)
	g0293  >  g0293_lrgBowl;
else
	g0293_lrgBowl  >  g0293;
endif;

if (t_hook == 1)
	cno_RtHookThook  >  cRtHookThook;
else
	cRtHookThook  >  cno_RtHookThook;
endif;

if (b_hook == 1)
	cno_TopBar  >  cTopBar;
else
	cTopBar  >  cno_TopBar;
endif;

if (h_stroke == 1)
	cno_VertStrk  >  cVertStrk;
	////cno_BarStem  >  cBarStem;
else
	cVertStrk  >  cno_VertStrk;
	////cBarStem  >  cno_BarStem;
endif;

if (r_tail == 1)
	cno_LCStyleRtail  >  cLCStyleRtail;
else
	cLCStyleRtail  >  cno_LCStyleRtail;
endif;

if (p_hook == 1)
	cno_BowlHook  >  cBowlHook;
else
	cBowlHook  >  cno_BowlHook;
endif;

if (rom == 1)
	cno_CommaStyle  >  cCommaStyle;
else
	cCommaStyle  >  cno_CommaStyle;
endif;

if (ezh == 1)
	cno_RevSigmaStyle  >  cRevSigmaStyle;
else
	cRevSigmaStyle  >  cno_RevSigmaStyle;
endif;
#endif // !BASIC

// ogonek processing must be in pass 2

if (apostrophe == 1)
	cno_Lrg  >  cLrg;
else
	cLrg  >  cno_Lrg;
endif;

if (modlowcolon == wide)
  cno_Wide >  cWide;	// a789, was gf1e9
  //gf1e9  >  gf1e9_wide;
else
  cWide  >  cno_Wide;
  //gf1e9_wide  >  gf1e9;
endif;

#if !BASIC

if (caron == 0)
	// European caron combinations (feature OFF)
	if (select_diac)
		cno_CaronEuro  g030c  >  cCaronEuro:(1 2) {comp {base.ref = @1; caron.ref = @2}}  _;
	else
		cno_CaronEuro  g030c  >  cCaronEuro:(1 2)  _;
	endif;
endif;
if (caron == 1)
	// Non-European caron but NFC: decompose and use standard caron
	cCaronEuro  _  >  cno_CaronEuro:1  g030c:1;
endif;

if (ou == 1)
	cno_OpenTop  >  cOpenTop;
else
	cOpenTop  >  cno_OpenTop;
endif;

if (emptyset == 1)
	cno_SlashZero  >  cSlashZero;
else
	cSlashZero  >  cno_SlashZero;
endif;

/***************
Obsolete feature:
if (ltnglottalstop == capHeight)
  g0294_lC  >  g0294;
else
  g0294  >  g0294_lC;
endif;
***************/

if (cyrillic_shha == 1)
  cno_UCStyleCyrShha  >  cUCStyleCyrShha;
else
  cUCStyleCyrShha  >  cno_UCStyleCyrShha;
endif;

#endif // !BASIC


#if ANDIKAfamily

if (zero == 1)
	cno_Slash  >  cSlash;
else
	cSlash  >  cno_Slash;
endif;

if (one == 1)
	cno_NoBase  >  cNoBase;
else
	cNoBase  >  cno_NoBase;
endif;

if (four == 1)
	cno_Open  >  cOpen;
else
	cOpen  >  cno_Open;
endif;

if (six_nine == 1)
	cno_Diag  > cDiag;
else
	cDiag  >  cno_Diag;
endif;

if (seven == 1)
	cno_Bar  >  cBar;
else
	cBar  >  cno_Bar;
endif;

if (i_hook == 1)
	cno_TailI  >  cTailI;
else
	cTailI  >  cno_TailI;
endif;

if (j_serif == 1)
	cno_TopLftSerif  >  cTopLftSerif;
else
	cTopLftSerif  >  cno_TopLftSerif;
endif;

if (l_hook == 1)
	cno_TailL  >  cTailL;
else
	cTailL  >  cno_TailL;
endif;

if (q_diagtail == 1)
	cno_DiagTail  >  cDiagTail;
else
	cDiagTail  >  cno_DiagTail;
endif;

if (q_point == 1)
	cno_Point  >  cPoint;
else
	cPoint  >  cno_Point;
endif;

if (t_tail == 1)
	cno_NoTailT  >  cNoTailT;
else
	cNoTailT  >  cno_NoTailT;
endif;

if (y_tail == 1)
	cno_NoTailY  > cNoTailY;
else
	cNoTailY  >  cno_NoTailY;
endif;

#endif	// ANDIKAfamily

endpass;  // sub - 1


pass(3)  {MaxBackup = 15; MaxRuleLoop = 30}	// substitution

// Convert i to dotless i when followed by upper diacritic

// decomposed sequences:
cno_Dotless  >  cDotless  /  _  DIASTR4(cnUDiaX)  cUDia;
// precomposed chars with i are done by decomposition:
cSpecialDotted  _  >  g_i_dotless  cSpecialDottedDia$1:1 / _  _  DIASTR4(cnUDiaX)  cUDia; 

// Now that ogonek has been composed with its vowels, do retrohook style if wanted:

#if !BASIC
if (ogonek == americanist)
	cno_RetroHookStyle > cRetroHookStyle;
else
	cRetroHookStyle > cno_RetroHookStyle;
endif;

//	g__aogonek	> g__a g0328_retroHookStyle:1;
//	g_aogonek	> g_a  g0328_retroHookStyle:1;
//	g__eogonek	> g__e g0328_retroHookStyle:1;
//	g_eogonek	> g_e  g0328_retroHookStyle:1;
//	g__iogonek	> g__i g0328_retroHookStyle:1;
//	g_iogonek_dotless > g_i_dotless g0328_retroHookStyle:1;
//	g_iogonek	> g_i  g0328_retroHookStyle:1;
//	g__uogonek	> g__u g0328_retroHookStyle:1;
//	g_uogonek	> g_u  g0328_retroHookStyle:1;
//	g01ea		> g__o g0328_retroHookStyle:1;
//	g01eb		> g_o  g0328_retroHookStyle:1;
//	g01ec		> g__omacron g0328_retroHookStyle:1;
//	g01ed		> g_omacron  g0328_retroHookStyle:1;
//	g_ogonek	> g_ogonek_retro_hook_style:1;
//	g0328		> g0328_retroHookStyle:1;
//endif;


// Handle superscript/subscript diacritics; currently the only one of interest is a diaeresis:
cno_Sup  >  cSup  /  (cModSuper cModSub)  _;

#endif // !BASIC

// Deprecated PUA

if (dep_pua == unicode51)
	cno_Dep51  >  cDep51  /  _ {pua};
endif;
if (dep_pua == unicode50)
	cno_Dep50  >  cDep50  /  _ {pua};
endif;
if (dep_pua == unicode41)
	cno_Dep41  >  cDep41  /  _ {pua};
endif;
if (dep_pua == unicode40)
	cno_Dep40  >  cDep40  /  _ {pua};
endif;

endpass;  // sub - 3


endtable; // substitution


#if !BASIC
#include "pitches.gdh"
#endif // !BASIC


table(positioning) {MUnits = 1000};

// Handle attachments

pass(1)

#define pos_rule(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}
#define pos_ruleSD(t, x, a, w, n) t x {attach {to = @1; at = a; with = w}; insert = 1; attached = 1} / ^ _ DIASTR4(n) _{attached == 0}

if (select_diac)
	pos_ruleSD(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_ruleSD(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_ruleSD(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_ruleSD(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_ruleSD(cTakesUDia, cUDia, US, UM, cnUDiaX);
else
	pos_rule(cTakesHDia, cHDia, HS, HM, cnHDiaX);
	pos_rule(cTakesLDia, cLDia, LS, LM, cnLDiaX);
	pos_rule(cTakesODia, cODia, OS, OM, cnODiaX);
	pos_rule(cTakesRDia, cRDia, RS, RM, cnRDiaX);
	pos_rule(cTakesUDia, cUDia, US, UM, cnUDiaX);
endif;

// Bridge diacritics handled by attachment need to have zero advance width,
// otherwise they push the second character out and away. (This wouldn't work if above
// we didn't reprocess attached diacritics using the ^ mechanism.)
#if !BASIC
cBridgeDiac {advance.x = 0}; 
#endif // !BASIC

endpass; // pos - 1


// Handle double-diacritics

pass(2)	// positioning

// Double-diacritics above: the ".1" gives the bounding box of the attached cluster of
// base + diacritics.

// Something on both sides:
cUDblDia {shift.y = max(@B.boundingbox.top.1, @A.boundingbox.top.1) - @D.boundingbox.bottom + 100m ; 
		shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		/ cTakesUDia=B  DIASTR3(cDia)  cLDblDia?  _=D  DIASTR3(cDia)  cTakesUDia=A;
// Beginning of line:
cUDblDia {shift.y = @B.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
		/ cTakesUDia=B  DIASTR5(cDia)  cLDblDia?  _=D;
// End of line:
cUDblDia {shift.y = @A.boundingbox.top.1 - @D.boundingbox.bottom + 100m ; insert = 1}
		/ DIASTR5(cDia)  cLDblDia?  _=D  cTakesUDia=A;

endpass; // pos - 2


pass(3)

// Double-diacritics below:

// Special case for two bridging diacritics:
g035f {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ; 
		  shift.x = (@A.boundingbox.width - @B.boundingbox.width)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
cLDblDia {shift.y = min(@B.boundingbox.bottom.1, @A.boundingbox.bottom.1) - @D.boundingbox.top -100m ; 
		  shift.x = (@A.boundingbox.width.1 - @B.boundingbox.width.1)/2; insert = 1}
		  / cTakesLDia=B  DIASTR3(cDia)  cUDblDia?  _=D  cUDblDia?  DIASTR3(cDia)  cTakesLDia=A;
cLDblDia {shift.y = @B.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ cTakesLDia=B  DIASTR5(cDia)  cUDblDia?  _=D ;
cLDblDia {shift.y = @A.boundingbox.bottom.1 - @D.boundingbox.top -100m ; insert = 1}
			/ DIASTR5(cDia)  cUDblDia?  _=D  cTakesLDia=A ;


endpass; // pos - 3

endtable; // positioning
